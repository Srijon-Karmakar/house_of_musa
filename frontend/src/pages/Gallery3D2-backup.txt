import React, { Suspense, useEffect, useRef, useState } from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";

import {
  KeyboardControls,
  useKeyboardControls,
  PointerLockControls,
  Html,
  Environment,
  useGLTF,
  ContactShadows,
  useTexture,
  useCursor,
} from "@react-three/drei";



import { Physics, RigidBody, CapsuleCollider } from "@react-three/rapier";
import * as THREE from "three";
import { useNavigate } from "react-router-dom";
import RapierReady from "./RapierReady.jsx";




const asset = (p) => {
  const base = (import.meta.env?.BASE_URL ?? '/').replace(/\/+$/, '');
  const rel = String(p).replace(/^\/+/, '');
  return `${base}/${rel}`;
};

const KEYMAP = [
  { name: "forward", keys: ["KeyW", "ArrowUp"] },
  { name: "backward", keys: ["KeyS", "ArrowDown"] },
  { name: "left", keys: ["KeyA", "ArrowLeft"] },
  { name: "right", keys: ["KeyD"] },
  // { name: "right", keys: ["KeyD", "ArrowRight"] },
  { name: "jump", keys: ["Space"] },
  { name: "sprint", keys: ["ShiftLeft", "ShiftRight"] },
  { name: "interact", keys: ["KeyE", "Enter"] },
];

const PAINTINGS = [
  {
    id: "p1",
    title: "Sportbit",
    // img: "https://picsum.photos/800/1200?random=11",
    img: asset('/gallery/sport.jpg'),
    position: [-9.9, 3.6, 3.9],
    rotation: [0, Math.PI, 0],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p2",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/art.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [-3.4, 3.6, 3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p3",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/mgmt.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [3.2, 3.6, 3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p4",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/restora.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [9.2, 3.6, 3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p5",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/shop.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [9.8, 3.6, -3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI * 2, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p6",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/tour.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [3.2, 3.6, -3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI * 2, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p7",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/sport.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [-3.4, 3.6, -3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI * 2, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
  {
    id: "p8",
    title: "Monochrome City",
    // img: "https://picsum.photos/1200/800?random=12",
    img: asset('/gallery/sport.jpg'),
    // position: [-1.8, 1.5, 4.0],
    position: [-9.9, 3.6, -3.9],
    // rotation: [0, Math.PI * 0.5, 0],
    rotation: [0, Math.PI * 2, 0],
    // size: [1.2, 0.9],
    size: [3.2, 4],
    desc: "Real-time sports analytics and club management.",
  },
];


const SPEED = 4.4;
const SPRINT = 8.8;
const JUMP = 14.5;
const PLAYER_HEIGHT = 3.35;   // ✅ human-sized, avoids ceiling collisions
const PLAYER_RADIUS = 0.35;

/* -------------------- 3D Scene -------------------- */
/** Loads the GLB, emits a spawn when ready (uses Empty named SpawnPoint/spawn/Start). */
function BalconyScene({ onSpawn }) {
  const { scene } = useGLTF("/models/gallery2.glb");

  useEffect(() => {
    const spawn =
      scene.getObjectByName("SpawnPoint") ||
      scene.getObjectByName("spawn") ||
      scene.getObjectByName("Start");

    if (spawn && onSpawn) {
      const w = new THREE.Vector3();
      spawn.getWorldPosition(w);
      const halfHeight = PLAYER_HEIGHT / 2 - PLAYER_RADIUS;
      const centerY = w.y + halfHeight + PLAYER_RADIUS; // = w.y + PLAYER_HEIGHT/2
      onSpawn([w.x, centerY, w.z]);
    } else if (onSpawn) {
      onSpawn([0, PLAYER_HEIGHT / 2, 3]); // fallback
    }

    // shadows + reflections on all meshes/materials
    scene.traverse((o) => {
      if (o.isLight) {
        o.castShadow = true;
      }
      if (o.isMesh) {
        o.castShadow = true;
        o.receiveShadow = true;
        if (o.material) {
          // boost IBL reflections a bit; tune 0.6–1.5
          if ("envMapIntensity" in o.material) o.material.envMapIntensity = 1.0;
          o.material.needsUpdate = true;
        }
      }
    });



  }, [scene, onSpawn]);

  return (
    <RigidBody type="fixed" colliders="trimesh">
      <primitive object={scene} />
    </RigidBody>
  );
}

function Player({ spawn = [0, 1.2, 3] }) {
  const { camera } = useThree();
  const bodyRef = useRef();

  // ✅ Proper keyboard store usage:
  const [, get] = useKeyboardControls(); // [subscribe, get]

  const forward = useRef(new THREE.Vector3()).current;
  const right = useRef(new THREE.Vector3()).current;
  const dir = useRef(new THREE.Vector3()).current;

  // Put camera near the head from the start
  useEffect(() => {
    camera.position.set(spawn[0], spawn[1] + (PLAYER_HEIGHT / 2) - PLAYER_RADIUS, spawn[2]);
  }, [camera, spawn]);

  useFrame(() => {
    const rb = bodyRef.current;
    if (!rb) return;

    const pressed = get(); // ✅ read current keys each frame
    const base = pressed.sprint ? SPEED * SPRINT : SPEED;

    //  camera-oriented movement (yaw only)
    // forward.set(0, 0, -1).applyQuaternion(camera.quaternion);
    // forward.y = 0;
    // forward.normalize();
    // right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

    // camera-oriented movement (yaw only) — robust & unambiguous
    forward.set(0, 0, -1).applyQuaternion(camera.quaternion);
    forward.y = 0;
    forward.normalize();

    // RIGHT = +X rotated by camera yaw (no cross-products)
    right.set(1, 0, 0).applyQuaternion(camera.quaternion);
    right.y = 0;
    right.normalize();



    dir.set(0, 0, 0);
    if (pressed.forward) dir.add(forward);
    if (pressed.backward) dir.add(forward.clone().negate());
    if (pressed.left) dir.add(right.clone().negate());
    if (pressed.right) dir.add(right);

    if (dir.lengthSq() > 0) dir.normalize().multiplyScalar(base);

    const lv = rb.linvel();
    rb.setLinvel({ x: dir.x, y: lv.y, z: dir.z }, true);

    // jump (simple ground check)
    if (pressed.jump && Math.abs(lv.y) < 0.05) {
      rb.applyImpulse({ x: 0, y: JUMP, z: 0 }, true);
    }

    // camera at capsule head
    const t = rb.translation();
    camera.position.set(t.x, t.y + (PLAYER_HEIGHT / 2) - PLAYER_RADIUS, t.z);
  });

  return (
    <RigidBody
      ref={bodyRef}
      position={[...spawn]}            // spawn is the capsule center
      colliders={false}
      enabledRotations={[false, false, false]}
      mass={1}
      friction={0.2}                   // ✅ lower friction to avoid “sticking”
      restitution={0}
      linearDamping={0.05}             // ✅ smooth stop (optional)
      canSleep={false}
    >
      <CapsuleCollider args={[PLAYER_HEIGHT / 2 - PLAYER_RADIUS, PLAYER_RADIUS]} />
    </RigidBody>
  );
}



function Painting({ id, title, img, position, rotation, size, desc }) {
  const tex = useTexture(img);
  useEffect(() => {
    if (!tex) return;
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = 8;
  }, [tex]);

  const planeRef = useRef();
  const [aimed, setAimed] = useState(false);
  useCursor(aimed);

  // Mark for raycast filtering
  useEffect(() => {
    if (planeRef.current) {
      planeRef.current.userData.isPainting = true;
      planeRef.current.userData.paintingMeta = { id, title, img, desc };
    }
  }, [id, title, img, desc]);

  return (
    <group position={position} rotation={rotation}>
      {/* simple frame */}
      <mesh position={[0, 0, -0.03]} castShadow receiveShadow>
        <boxGeometry args={[size[0] + 0.08, size[1] + 0.08, 0.06]} />
        {/* <meshStandardMaterial metalness={0.55} roughness={0.35} color="#3a3a3a" /> */}
        <meshStandardMaterial metalness={0} roughness={0} color="#00000008" />
      </mesh>

      {/* art plane */}
      <mesh
        ref={planeRef}
        // castShadow
        // receiveShadow
        castShadow={false}
        receiveShadow={false}
        position={[0, 0, 0.012]}
        onPointerOver={() => setAimed(true)}
        onPointerOut={() => setAimed(false)}
      >
        <planeGeometry args={size} />
        <meshStandardMaterial
          map={tex}
          roughness={0.12}
          metalness={0}
          toneMapped
          polygonOffset
          polygonOffsetFactor={-1}
          polygonOffsetUnits={-1}
        />   {/* default: roughness={0.6} metalness={0.08} */}
      </mesh>

      {/* soft glow when aimed */}
      {/* {aimed && (
        <mesh position={[0, 0, 0.01]}>
          <planeGeometry args={[size[0] + 0.04, size[1] + 0.04]} />
          <meshBasicMaterial color="#ffffff29" transparent opacity={0.10} depthWrite={false}
          blending={THREE.AdditiveBlending} /> 
        </mesh>
      )} */}

      {aimed && (
        <mesh position={[0, 0, 0.01]} renderOrder={999}>
          <planeGeometry args={[size[0] + 0.04, size[1] + 0.04]} />
          <meshBasicMaterial
            color="#ffffff"
            transparent
            opacity={0.14}
            depthWrite={false}
            depthTest={false}
            blending={THREE.AdditiveBlending}
            toneMapped={false}
          />
        </mesh>
      )}

      {/* hint */}
      <Html
        position={[0, -size[1] * 0.65, 0]}
        center
        style={{
          padding: "6px 10px",
          borderRadius: 10,
          background: "rgba(0, 0, 0, 0.11)",
          color: "#fff",
          fontSize: 8,
          border: "1px solid rgba(255, 255, 255, 0.1)",
          pointerEvents: "none",
          whiteSpace: "nowrap",
        }}
      >
        {title} • Press <b>E</b> / Click
      </Html>
    </group>
  );
}

// Manages raycast from the crosshair + open on E / click
function PaintingsManager({ config, onOpen, maxDistance = 8, pointerLocked = false }) {
  const groupRef = useRef();
  const ray = useRef(new THREE.Raycaster()).current;
  const { camera } = useThree();
  const [, get] = useKeyboardControls();

  // Center of screen NDC
  const ndc = useRef(new THREE.Vector2(0, 0)).current;

  // Per-frame: handle E/Enter interaction from the center
  useFrame(() => {
    const pressed = get();
    if (!pressed.interact) return;

    // If you want interaction only in FPS mode, keep this:
    if (!pointerLocked) return;

    // Fresh raycast from center
    ray.setFromCamera(ndc, camera);
    const root = groupRef.current?.children ?? [];
    const hits = ray.intersectObjects(root, true);
    const h = hits.find((x) => x.object?.userData?.isPainting && x.distance <= maxDistance);
    if (h?.object?.userData?.paintingMeta) onOpen?.(h.object.userData.paintingMeta);
  });

  // Robust CLICK/TAP handler (works across browsers + pointer lock)
  useEffect(() => {
    const handleTryOpen = (e) => {
      // Optional: require FPS mode; remove this if you want clicks even when unlocked
      if (!pointerLocked) return;

      // Left mouse only when it is a mouse event
      if (e.type === "mousedown" && e.button !== 0) return;

      // Raycast from screen center (crosshair)
      ray.setFromCamera(ndc, camera);
      const root = groupRef.current?.children ?? [];
      const hits = ray.intersectObjects(root, true);
      const h = hits.find((x) => x.object?.userData?.isPainting && x.distance <= maxDistance);
      if (h?.object?.userData?.paintingMeta) onOpen?.(h.object.userData.paintingMeta);
    };

    // Listen on window to avoid canvas-specific quirks under pointer lock
    window.addEventListener("mousedown", handleTryOpen);
    window.addEventListener("pointerdown", handleTryOpen);
    window.addEventListener("touchstart", handleTryOpen, { passive: true });

    return () => {
      window.removeEventListener("mousedown", handleTryOpen);
      window.removeEventListener("pointerdown", handleTryOpen);
      window.removeEventListener("touchstart", handleTryOpen);
    };
  }, [camera, ray, maxDistance, onOpen, pointerLocked, ndc]);

  return (
    <group ref={groupRef}>
      {config.map((p) => (
        <Painting key={p.id} {...p} />
      ))}
    </group>
  );
}







/* Bridge to listen to lock/unlock from inside Canvas and update state in parent */
function LockBridge({ plcRef, setLocked }) {
  useEffect(() => {
    const plc = plcRef.current;
    if (!plc) return;
    const onLock = () => setLocked(true);
    const onUnlock = () => setLocked(false);
    plc.addEventListener("lock", onLock);
    plc.addEventListener("unlock", onUnlock);
    return () => {
      plc.removeEventListener("lock", onLock);
      plc.removeEventListener("unlock", onUnlock);
    };
  }, [plcRef, setLocked]);
  return null;
}

/* -------------------- Page -------------------- */
export default function GalleryPage() {
  const [locked, setLocked] = useState(false);
  const [spawn, setSpawn] = useState(null);
  const [active, setActive] = useState(null);
  const plcRef = useRef();
  const navigate = useNavigate();


  return (
    <>
      {/* UI OUTSIDE CANVAS */}
      {/* <button
        onClick={() => navigate("/")}
        style={{
          position: "fixed", top: 16, left: 16, zIndex: 40,
          background: "rgba(0,0,0,0.55)", color: "#fff",
          padding: "8px 12px", borderRadius: 10, border: "1px solid rgba(255,255,255,0.15)"
        }}
      >
        ⟵ Exit
      </button> */}

      {!locked && (
        <button
          onClick={() => plcRef.current?.lock()}
          style={{
            position: "fixed", inset: 0, margin: "auto",
            width: 280, height: 120, background: "rgba(0,0,0,0.6)",
            color: "#fff", border: "1px solid rgba(255,255,255,0.2)",
            borderRadius: 106, fontSize: 16, backdropFilter: "blur(4px)", zIndex: 30
          }}
        >
          Click to enter • WASD / Shift / Space
        </button>
      )}

      {/* Crosshair */}
      <div
        style={{
          position: "fixed", left: "50%", top: "50%", transform: "translate(-50%, -50%)",
          width: 8, height: 8, border: "2px solid rgba(255,255,255,0.8)", borderRadius: 9999,
          backgroundColor: "rgba(255, 255, 255, 1)",
          pointerEvents: "none", opacity: locked ? 1 : 0.35, zIndex: 20
        }}
      />

      {/* Painting viewer modal */}
      {active && (
        <div
          style={{
            position: "fixed",
            inset: 0,
            zIndex: 50,
            display: "grid",
            placeItems: "center",
            background: "rgba(0, 0, 0, 0.63)",
            // backdropFilter: "blur(4px)",
            // background: "transparent",
            transition: "background 160ms ease",
          }}
          onClick={() => setActive(null)}
        >
          <div
            className="modalCard"
            style={{
              background: "#ffffff4c",
              backdropFilter: "blur(104px)",
              border: "1px solid rgba(255,255,255,0.15)",
              borderRadius: 50,
              padding: 16,
              width: "min(56vw, 960px)",
              maxHeight: "86vh",
              overflow: "auto",
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10 }}>
              <h3 style={{ color: "#fff", fontSize: 18, fontWeight: 700 }}>{active.title}</h3>
              <button
                onClick={() => setActive(null)}
                style={{
                  background: "rgba(255,255,255,0.08)",
                  color: "#fff",
                  border: "1px solid rgba(255,255,255,0.15)",
                  borderRadius: 10,
                  padding: "6px 10px",
                }}
              >
                Close
              </button>
            </div>
            <img
              src={active.img}
              alt={active.title}
              style={{ width: "100%", height: "auto", borderRadius: 10, display: "block" }}
            />
            {/* Description block */}
            <div
              style={{
                marginTop: 12,
                color: "#fff",
                lineHeight: 1.6,
                fontSize: 14,
                opacity: 0.95,
              }}
            >
              {active.desc || "—"}
            </div>
          </div>
        </div>
      )}


      <KeyboardControls map={KEYMAP}>
        {/* <Canvas
          shadows
          gl={{ antialias: true, physicallyCorrectLights: true, outputColorSpace: THREE.SRGBColorSpace }}
          onCreated={({ gl, scene }) => {
            gl.setClearColor("#000");
            gl.toneMapping = THREE.ACESFilmicToneMapping;
            gl.toneMappingExposure = 1.0;
            gl.shadowMap.enabled = true;
            gl.shadowMap.type = THREE.PCFSoftShadowMap;
            scene.fog = new THREE.FogExp2("#0c0c12", 0.02);
          }}
          camera={{ fov: 68, near: 0.1, far: 200 }}
        > */}

        <Canvas
          // shadows
          gl={{
            antialias: true,
            alpha: true,
            premultipliedAlpha: true,
            physicallyCorrectLights: true,
            outputColorSpace: THREE.SRGBColorSpace
          }}
          onCreated={({ gl, scene }) => {
            // gl.setClearColor("#000000");
            gl.setClearColor("#0b0b12", 1);
            gl.toneMapping = THREE.ACESFilmicToneMapping;
            gl.toneMappingExposure = 1.0;
            gl.shadowMap.enabled = true;
            gl.shadowMap.type = THREE.PCFSoftShadowMap;
            scene.fog = new THREE.FogExp2("#0c0c12", 0.02);
          }}
          camera={{ fov: 68, near: 0.1, far: 200 }}
        >


          <ambientLight intensity={0.35} />
          <directionalLight
            position={[5, 8, 3]}
            intensity={1.1}
            castShadow
            shadow-bias={-0.0003}
            shadow-mapSize-width={2048}
            shadow-mapSize-height={2048}
          />
          <Environment
            files="/hdr/jungle.hdr"
            background
            blur={0}
          />
        <RapierReady>
          <Physics gravity={[0, -9.81, 0]}>
            <Suspense fallback={<Html center style={{ color: "#fff" }}>Loading…</Html>}>
              <BalconyScene onSpawn={setSpawn} />
            </Suspense>
            <ContactShadows
              position={[0, 0.01, 0]}
              opacity={0.5}
              scale={30}
              blur={2.5}
              far={20}
            />
            <PaintingsManager config={PAINTINGS} onOpen={setActive} maxDistance={8} pointerLocked={locked} />

            {spawn && <Player spawn={spawn} />}
          </Physics>
          </RapierReady>

          <PointerLockControls ref={plcRef} />
          <LockBridge plcRef={plcRef} setLocked={setLocked} />
        </Canvas>
      </KeyboardControls>
    </>
  );
}

useGLTF.preload("/models/gallery2.glb");